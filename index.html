<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Catch the Falling Stars</title>
<style>
  body {
    margin: 0;
    height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    background: linear-gradient(#020111, #191970); 
    font-family: Arial, sans-serif;
  }

  .game-container {
    padding: 15px;
    background: rgba(255, 255, 255, 0.05);
    border: 2px solid #fff;
    border-radius: 15px;
    box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
  }

  canvas {
    display: block;
    background: #111; 
    border-radius: 10px;
  }
</style>
</head>
<body>
<div class="game-container">
  <canvas id="gameCanvas" width="700" height="600"></canvas>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const basket = { x: 350, y: canvas.height - 30, w: 100, h: 20, speed: 10 };

let stars = [];
let score = 0;
let highScore = 0;
let lives = 10;
let starSpeed = 2;
let spawnInterval = 1000;
let lastSpawn = 0;
let lastDifficultyIncrease = Date.now();
let gameOver = false;

const keys = { left: false, right: false };
document.addEventListener('keydown', e => {
  if (e.code === 'ArrowLeft') keys.left = true;
  if (e.code === 'ArrowRight') keys.right = true;
  if (e.code === 'Space' && gameOver) restartGame();
});
document.addEventListener('keyup', e => {
  if (e.code === 'ArrowLeft') keys.left = false;
  if (e.code === 'ArrowRight') keys.right = false;
});

function gameLoop(timestamp) {
  update(timestamp);
  draw(timestamp);
  if (!gameOver) requestAnimationFrame(gameLoop);
}

function update(timestamp) {
  if (gameOver) return;
  if (keys.left) basket.x -= basket.speed;
  if (keys.right) basket.x += basket.speed;
  basket.x = Math.max(0, Math.min(canvas.width - basket.w, basket.x));
  if (timestamp - lastSpawn > spawnInterval) {
    spawnStar();
    lastSpawn = timestamp;
  }
  for (let i = stars.length - 1; i >= 0; i--) {
    stars[i].y += stars[i].speed;
    if (stars[i].y + stars[i].r > basket.y &&
        stars[i].x > basket.x && stars[i].x < basket.x + basket.w) {
      stars.splice(i, 1);
      score++;
      if (score > highScore) highScore = score;
      continue;
    }
    if (stars[i].y > canvas.height) {
      stars.splice(i, 1);
      lives--;
      if (lives <= 0) endGame();
    }
  }
  if (Date.now() - lastDifficultyIncrease > 5000) {
    starSpeed += 0.5;
    spawnInterval = Math.max(400, spawnInterval - 50);
    lastDifficultyIncrease = Date.now();
  }
}

function draw(timestamp) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = '#8B4513';
  ctx.fillRect(basket.x, basket.y, basket.w, basket.h);
  stars.forEach(s => {
    const twinkle = (Math.sin((timestamp / 100) + s.phase) + 1) / 2;
    ctx.fillStyle = `rgba(255, 255, ${150 + twinkle * 105}, 1)`;
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
    ctx.fill();
  });
  ctx.fillStyle = 'white';
  ctx.font = '20px Arial';
  ctx.fillText(`Score: ${score}`, 10, 25);
  ctx.fillText(`High Score: ${highScore}`, canvas.width - 160, 25);
  ctx.fillText(`Lives: ${lives}`, canvas.width / 2 - 30, 25);
  if (gameOver) {
    ctx.fillStyle = 'red';
    ctx.font = '40px Arial';
    ctx.fillText('GAME OVER', canvas.width / 2 - 120, canvas.height / 2 - 20);
    ctx.font = '20px Arial';
    ctx.fillStyle = 'yellow';
    ctx.fillText('Press SPACE to Restart', canvas.width / 2 - 110, canvas.height / 2 + 20);
  }
}

function spawnStar() {
  const x = Math.random() * (canvas.width - 20) + 10;
  stars.push({ x, y: 0, r: 8, speed: starSpeed, phase: Math.random() * Math.PI * 2 });
}

function endGame() {
  gameOver = true;
}

function restartGame() {
  score = 0;
  lives = 10;
  starSpeed = 2;
  spawnInterval = 1000;
  stars = [];
  gameOver = false;
  lastSpawn = 0;
  lastDifficultyIncrease = Date.now();
  requestAnimationFrame(gameLoop);
}
requestAnimationFrame(gameLoop);
</script>
</body>

</html>
